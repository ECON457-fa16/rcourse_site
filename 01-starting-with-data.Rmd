---
title: Getting started with data
---

```{r, echo=FALSE}
knitr::opts_chunk$set(results="markup")
```

## Analyzing Iris Data

We are studying differences in morphology in two species of Iris: Iris setosa 
and Iris versicolor.

### We want to:

* load that data into memory,
* Explore the data, 
* Calculate some summary statistics, 
* Explore the dataset visually, 
* plot the result.

To do all that, we'll have to learn a little bit about programming.

### Objectives
* Explain what a library is, and what libraries are used for.
* Load an R library and use the things it contains.
* Read tabular data from a file into a program.
* Assign values to variables.
* Learn about data types
* Select individual values and subsections from data.
* Perform operations on arrays of data.
* Display simple graphs.

## RStudio Projects
* Projects in RStudio help keep our code, data, and outputs well organized
* when we quit RStudio, it will help us remember where we left off
* Open a new project, in a new directory -> Empty Project
* Look around  - you'll see where we are
* Create a directory to hold the data

```{r}
getwd()

```

## Loading Data

Words are useful, but what's more useful are the sentences and stories we use 
them to build. Similarly, while a lot of powerful tools are built into 
languages like R, even more lives in the libraries they are used to build.
Importing a library is like getting a piece of lab equipment out of a storage 
locker and setting it up on the bench. Once it's done, we can ask the library 
to do things for us.

To load our iris data, we need to download our data to a place we can use it
We will use `dir.create()` and `read.csv()`. These are built-in functions in R. 
Let's check out the help screen.

```{r}
dir.create("data")

```

* download the iris file
* put it in your data directory for these exercises

Load the data into R:

```{r}
read.csv('data/iris.csv')
```

The expression `read.csv()` is a function that asks R to load a `.csv` file 
into R's workspace as a data frame.

`read.csv()` has many arguments including the name of the file we want to read, 
and the delimiter that separates values on a line. 

When we are finished typing and press `Control+Enter` on Windows or 
`Cmd + Return` on Mac, the console runs our command. 
Since we haven't told it to do anything else with the function's output, the 
console displays it.
In this case, that output is the data we just loaded. 

Our call to `read.csv()` read the file, but didn't save the data as an object. 
To do that, we need to assign the data frame to a variable. 
A variable is just a name for a value, such as `x`, `current_temperature`, or 
`subject_id`. 
We can create a new variable simply by assigning a value to it using `<-`

```{r}
weight_kg <- 55
```

Once a variable has a value, we can print it:

```{r}
weight_kg
```

and do arithmetic with it:

```{r}
2.2 * weight_kg
```

We can use the function `paste()` to strings made up from different objects, if 
we separate them with commas.

```{r}
paste("weight in pounds:", 2.2 * weight_kg)
```

We can also change an object's value by assigning it a new value:

```{r}
weight_kg <- 57.5
# weight in kilograms is now
weight_kg
```

If we imagine the variable as a sticky note with a name written on it, 
assignment is like putting the sticky note on a particular value
This means that assigning a value to one object does not change the values of 
other variables.

For example, let's store the subject's weight in pounds in a variable

```{r}
weight_lb <- 2.2 * weight_kg
# weight in kg...
weight_kg
# ...and in pounds
weight_lb
```

and then change `weight_kg`:

```{r}
weight_kg <- 100.0
# weight in kg now...
weight_kg
# ...and in weight pounds still
weight_lb
```

__Updating a Variable__

Since `weight_lb` doesn't "remember" where its value came from, it isn't 
automatically updated when `weight_kg` changes. This is different from the way 
spreadsheets work.

__Challenges__

Draw diagrams showing what variables refer to what values after each statement in the following program:

```{r}	
mass <- 47.5
age  <- 122
mass <- mass * 2.0
age  <- age - 20
```

We can also add to variable that are vectors, and update them by making them 
longer. For example, if we are creating a vector of patient weights, we could 
update that vector using `c()`. `c()` takes any number of vectors as arguments, 
and combines or *concatenates* them, in the order supplied, into a single vector.

```{r}
weights <- 100
weights <- c(weights, 80)
```

What happens here is that we take the original vector weights, and we are adding 
the second item to the end of the first one. We can do this over and over again 
to build a vector or a dataset. As we program, this may be useful to autoupdate 
results that we are collecting or calculating.

Now that we know how to assign things to variables, let's re-run `read.csv` and 
save its result:

```{r}
dat <- read.csv('data/iris.csv')
```

This statement doesn't produce any output because assignment doesn't display 
anything. If we want to check that our data has been loaded, we can print the 
variable's value:

```{r}
dat
```

It's important to note that anything we do with `dat` here will not affect the 
original `csv` file. This is an important concept of reproducibility - don't 
touch your original data!

For large data sets it is convenient to use the `head()` to display the first 
few rows of data, or `tail()` to see the end

```{r}
head(dat)
tail(dat)
```

In RStudio's environment pane, you can also click on the little table icon next
to the data frame name.

__BREAK__

* Make sure everyone has imported the data
* How many rows and columns there are
* What kind of data type is it?

## Manipulating Data

Now that our data is in memory, we can start doing things with it. 
First, let's ask what type of thing `dat` *is*:

```{r}
class(dat)
str(dat)
summary(dat)
```

The output tells us that data currently is a data frame in R. 
This is similar to a spreadsheet in MS Excel, that many of us are familiar with 
using.

### data frames
The *de facto* data structure for most tabular data and what we use for statistics.

Data frames can have additional attributes such as `rownames()`, which can be 
useful for annotating data, like `subject_id` or `sample_id`. But most of the 
time they are not used.

Some additional information on data frames:

* Usually created by `read.csv()` and `read.table()`.
* Can convert to matrix with `data.matrix()` (preferred) or `as.matrix()`
* Coercion will be forced and not always what you expect.
* Can also create with `data.frame()` function.
* Find the number of rows and columns with `nrow(dat)` and `ncol(dat)`, 
respectively.

#### Useful data frame functions

* `head()` - shown first 6 rows
* `tail()` - show last 6 rows
* `dim()` - returns the dimensions
* `nrow()` - number of rows
* `ncol()` - number of columns
* `str()` - structure of each column
* `names()` - shows the `names` attribute for a data frame, which gives the column names.

`str` output tells us the dimensions and the data types (int is integer) of each column.

We can see what its shape is like this:

```{r}
dim(dat)
nrow(dat)
ncol(dat)
```

This tells us that data has `r nrow(dat)` rows and `r ncol(dat)` columns.

### Referencing Columns

When referencing a column, the `$` operator is used to separate the data frame 
and the column name. In a data frame, each column is a _vector_ of the same 
length. Let's look at the petal widths:

```{r}
dat$Petal.Width
```

Now say we want to get the mean of the petal widths, or the maximum of the sepal 
lengths:

```{r}
mean(dat$Petal.Width)
max(dat$Sepal.Length)
```

You can also use the `$` operator to reference columns that don't yet exist, but
you would like to create.  For example, the measurements in this dataset are in 
cm, but perhaps we want to compare sepal lengths with another dataset that has 
measurements in inches:

```{r}
dat$Sepal.Length.in <- dat$Sepal.Length / 2.54
head(dat)
```

Or, perhaps what we are really interested in is the ratio of petal length to 
petal width:

```{r}
dat$Petal.LW.Ratio <- dat$Petal.Length / dat$Petal.Width
head(dat)
```

<!-- This may be a good place to talk about vectors -->

### Indexing

We talked about vectors before, and indexing them.  Each column in a data frame 
is a vector, and can be indexed as such.

If we want to get a single value from the data frame, we must provide an row and 
column indices for the value we want in square brackets: `dataframe[rows,columns]`

```{r}
# first value in first column in dat
dat[1, 1]
# third value in fifth column in dat
dat[3, 5]
```

An index like `[30, 3]` selects a single element of data frame, but we can 
select sections as well. Entering nothing in either the rows or columns spot 
selects all.
For example, we can select the first ten rows across all columns, like this. :

```{r}
dat[1:10,]
```

The notation `1:10` means, "Start at index 1 and go to index 10." 

We don't have to take consecutive values, we can use `c()` to select certain 
values or groups of values:

```{r}
dat[c(1:10, 20:30),]
```

Here we have taken rows 1 through 10 and 20 through 30.

Columns can also be referenced by name:

```{r}
dat[, "Petal.Length"] # Returns all rows
dat[, c("Petal.Length", "Species")]  # Can specify more than one column by using a character vector

```

#### Indexing using conditionals

Sometimes we are interested in extracting data based on something else.  Lets 
say we want to look at all of the flowers measured that had really wide sepals:

```{r}
mean.sw <- mean(dat$Sepal.Width) # First find the average sepal width
mean.sw
dat[dat$Sepal.Width > mean.sw, ]
```

Let's break that down a little. `dat$Sepal.Width > mean.sw` returns a _Logical_ 
vector of the same length as `dat$Sepal.Width`; that is a vector of `TRUE` and 
`FALSE` based on testing each element of `dat$Sepal.Width` to see if it is 
greater than `mean.sw`.

```{r}
dat$Sepal.Width > mean.sw
```

When you put that logical vector inside the row index, just the rows which are 
`TRUE` are returned. This type of conditional indexing is very powerful:

```{r}
dat[dat$Species == "setosa",]
```

TODO: Something a bit more complicated here maybe? Then a quick plot in base graphics, then dplyr

When analyzing, we often want to look at partial statistics, such as the maximum value per patient or the average value per day. 
One way to do this is to select the data we want to create a new temporary array, then ask it to do the calculation:

```{r}
# patient_1 <- dat[1, ] # first row, all of the columns
# max(patient_1)        # max inflammation for patient 1
```

We don't actually need to store the row in a variable of its own. 
Instead, we can combine the selection and the method call:

```{r}
# max(dat[2,])          # max inflammation for patient 2
```

__EXERCISES__

1. If `dat` holds our data frame of patient data, what does `dat[3:3, 4:4]` produce? 
What about `dat[3:3, 4:1]`? Explain the results to the person sitting next to you


## Functions - Operations Across Axes

What if we need the maximum inflammation for all patients, or the average for each day? 
As the diagram below shows, we want to perform the operation across an axis:

<!-- FIXME: needs I presume the rBlocks code here to produce the figure? -->

To support this, in R we can use the `apply()` function:

```{r, eval=FALSE}
help(apply) # r ?apply
```

`apply()` allows us to repeat a function on all of the rows (`MARGIN = 1`), columns (`2`), or both(`1:2`) of a matrix (or higher dimensions of an array).

If each row is a patient, and we want to know each patient's average inflammation, we will need to iterate our method across all of the rows. 
	
```{r}
# avg_inflammation <- apply(dat, 2, mean)
```

Some operations, such as the column-wise means have more efficient alternatives. For example `rowMeans()` and `colMeans()`.
```{r}
# colMeans(dat)
```

### Challenge  
1. Find the maximum and minimum values for inflammation at each day (rows are patients, and columns are days).
2. Save these values to a varible.
3. What is the length of your new variable?

```{r, echo=FALSE}
# min_inflammation <- apply(dat, 2, min)
# max_inflammation <- apply(dat, 2, max)
```

We can also create a vector of our study days (the number of columns in data)

```{r}
# tempo <- 1:40
# r
# tempo <- 1:ncol(dat)
```

Notice that the object was named `tempo` instead of `time`. `time` is a R built-in function, and as good practice avoid giving existing function names to your objects. 

Now that we have all this summary information, we can put it back together into a data frame that we can use for further analysis and plotting, provided they are the same length.

```{r}
# d.summary <- data.frame(tempo, avg_inflammation, min_inflammation, max_inflammation)
```

## Plotting  
The mathematician Richard Hamming once said

> The purpose of computing is insight, not numbers

and the best way to develop insight is often to visualize data. Visualization deserves an entire lecture (or course) of its own, but we can explore a few features of R's base plotting package. 

Lets use the average inflammation data that we saved and plot it over the study time. 

```{r, plot-avg-inflammation}
# plot(tempo, avg_inflammation)
```

The result is roughly a linear rise and fall, which is suspicious: based on other studies, we expect a sharper rise and slower fall. Let's have a look at two other statistics:

```{r, plot-max-inflammation}
# plot(tempo, max_inflammation)
```

```{r, plot-min-inflammation}
 # plot(tempo, min_inflammation)
```
The maximum value rises and falls perfectly smoothly, while the minimum seems to be a step function. Neither result seems particularly likely, so either there's a mistake in our calculations or something is wrong with our data.

__EXERCISES__

1. Create a plot showing the standard deviation of the inflammation data 
for each day across all patients.

## Key Points

* Import a package into your workspace using `library("pkgname")`.
* The key data types in R?
* Use `variable <- value` to assign a value to a variable in order to record it in memory.
* Objects are created on demand whenever a value is assigned to them.
* Use `print(something)` (or just `something`) to display `something`.
* The expression `dim()` gives the dimensions of a data frame or matrix.
* Use `object[x, y]` to select a single element from an array.
* Object indices start at 1.
* Use `from:to` to specify a sequence that includes the indices from `from` to `to`.
* Use `#` to add comments to programs.
* Use `mean()`, `max()`, `min()` and `sd()` to calculate simple statistics.
* Update vectors using `c()`
<!-- * Write a simple for loop -->
* Use base R to create simple visualizations.

## Next Steps

Our work so far has convinced us that something's wrong with our first data file. We would like to check the other 11 the same way, but typing in the same commands repeatedly is tedious and error-prone. Since computers don't get bored (that we know of), we should create a way to do a complete analysis with a single command, and then figure out how to repeat that step once for each file. These operations are the subjects of the next two lessons.
